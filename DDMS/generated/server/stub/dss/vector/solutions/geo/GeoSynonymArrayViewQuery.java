/*******************************************************************************
 * Copyright (C) 2018 IVCC
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package dss.vector.solutions.geo;

import java.util.HashSet;

import com.runwaysdk.dataaccess.MdAttributeReferenceDAOIF;
import com.runwaysdk.dataaccess.MdBusinessDAOIF;
import com.runwaysdk.dataaccess.metadata.MdBusinessDAO;
import com.runwaysdk.query.AND;
import com.runwaysdk.query.Coalesce;
import com.runwaysdk.query.Condition;
import com.runwaysdk.query.Join;
import com.runwaysdk.query.QueryFactory;
import com.runwaysdk.query.Selectable;
import com.runwaysdk.query.SelectableReference;
import com.runwaysdk.query.SelectableSQLCharacter;
import com.runwaysdk.query.ValueQuery;
import com.runwaysdk.query.ViewQueryBuilder;
import com.runwaysdk.system.metadata.MdBusinessQuery;

import dss.vector.solutions.geo.generated.GeoEntityQuery;
import dss.vector.solutions.geo.generated.GeoEntityQuery.GeoEntityQueryReference;

/**
 *
 * @author Autogenerated by RunwaySDK
 */
public class GeoSynonymArrayViewQuery extends dss.vector.solutions.geo.GeoSynonymArrayViewQueryBase  implements com.runwaysdk.generation.loader.Reloadable
{
  public GeoSynonymArrayViewQuery(com.runwaysdk.query.QueryFactory queryFactory)
  {
    super(queryFactory);
    this.buildQuery(new DefaultGeoSynonymArrayViewBuilder(queryFactory));
  }
  
  public GeoSynonymArrayViewQuery(com.runwaysdk.query.QueryFactory queryFactory, GeoSynonymArrayView view)
  {
    super(queryFactory);
    this.buildQuery(new DefaultGeoSynonymArrayViewBuilder(queryFactory, view));
  }

  public GeoSynonymArrayViewQuery(com.runwaysdk.query.QueryFactory queryFactory, ViewQueryBuilder viewQueryBuilder)
  {
    super(queryFactory, viewQueryBuilder);
  }

  class DefaultGeoSynonymArrayViewBuilder extends com.runwaysdk.query.ViewQueryBuilder implements com.runwaysdk.generation.loader.Reloadable
  {
    GeoSynonymQuery geoSynonymQuery;
    HasSynonymQuery synonymRelQuery;
    GeoEntityQuery geoEntityQuery;
    MdBusinessQuery universalQuery;
    ValueQuery vq;
    GeoSynonymArrayView view;
    Condition condition;
    
    Coalesce geoTypeLabel;
    Coalesce geoEntityLabel;
    Selectable synonymNames;
    Selectable synonymIds;
    SelectableSQLCharacter geoType;
    GeoEntityQueryReference geoEntity;
    
    public DefaultGeoSynonymArrayViewBuilder(com.runwaysdk.query.QueryFactory queryFactory, GeoSynonymArrayView view)
    {
      this(queryFactory);
      
      this.view = view;
    }
    
    public DefaultGeoSynonymArrayViewBuilder(com.runwaysdk.query.QueryFactory queryFactory)
    {
      super(queryFactory);
      
      geoSynonymQuery = new GeoSynonymQuery(queryFactory);
      synonymRelQuery = new HasSynonymQuery(queryFactory);
      geoEntityQuery = new GeoEntityQuery(queryFactory);
      universalQuery = new MdBusinessQuery(queryFactory);
      
      this.condition = null;
    }

    protected GeoSynonymArrayViewQuery getViewQuery()
    {
      return (GeoSynonymArrayViewQuery)super.getViewQuery();
    }

    
//  SELECT
//  geo.geo_id,
//  lbl.default_locale
//  string_agg(syn.entity_name,','),
//  from
//  geo_synonym syn
//  INNER JOIN has_synonym syn_rel on syn_rel.child_id=syn.id
//  INNER JOIN geo_entity geo on geo.id=syn_rel.parent_id
//  INNER JOIN geo_entity_entity_label lbl on lbl.id=geo.entity_label
//  GROUP BY geo_id, default_locale
    
    /**
     * build the select clause
     */
    protected void buildSelectClause()
    {
      GeoSynonymArrayViewQuery vQuery = this.getViewQuery();
      vq = vQuery.valueQuery;
      
      final String entity_name = MdBusinessDAO.getMdBusinessDAO(GeoSynonym.CLASS).definesAttribute(GeoSynonym.ENTITYNAME).getColumnName();
      final String id = MdBusinessDAO.getMdBusinessDAO(GeoSynonym.CLASS).definesAttribute(GeoSynonym.ID).getColumnName();
//      final String package_name = MdBusinessDAO.getMdBusinessDAO(MdBusiness.CLASS).definesAttribute(MdBusiness.PACKAGE).getColumnName();
//      final String type_name = MdBusinessDAO.getMdBusinessDAO(MdBusiness.CLASS).definesAttribute(GeoSynonym.TYPENAME).getColumnName();
     
      geoTypeLabel = universalQuery.getDisplayLabel().localize();
      geoEntityLabel = geoEntityQuery.getEntityLabel().localize();
      synonymNames = vq.aSQLAggregateCharacter(GeoSynonymArrayView.SYNONYMNAMES, "string_agg(" + entity_name + ", ',')", GeoSynonymArrayView.SYNONYMNAMES, GeoSynonymArrayView.SYNONYMNAMES);
      synonymIds = vq.aSQLAggregateCharacter(GeoSynonymArrayView.SYNONYMIDS, "string_agg(" + geoSynonymQuery.getTableAlias() + "." + id + ", ',')", GeoSynonymArrayView.SYNONYMIDS, GeoSynonymArrayView.SYNONYMIDS);
      geoType = vq.aSQLCharacter("full_type", "concat_ws('.', package_name, type_name)");
      
      
      // Hack: There needs to be a geoEntityQuery.reference() method that will return a GeoEntityQueryReference object built for us. Because this method doesn't exist, we're going to do it manually.
      SelectableReference ref = synonymRelQuery.getParent();
      MdAttributeReferenceDAOIF mdAttributeReferenceDAOIF = (MdAttributeReferenceDAOIF) ref.getMdAttributeIF();
      String definingTableName = geoEntityQuery.getMdClassIF().getTableName();
      String definingTableAlias = geoEntityQuery.getTableAlias();
      MdBusinessDAOIF referenceMdBusinessIF = mdAttributeReferenceDAOIF.getReferenceMdBusinessDAO();
      String referenceTableName = referenceMdBusinessIF.getTableName();
      String referenceTableAlias = vq.getQueryFactory().getTableAlias(mdAttributeReferenceDAOIF.definesAttribute(), referenceTableName);
      geoEntity = new GeoEntityQueryReference(mdAttributeReferenceDAOIF, mdAttributeReferenceDAOIF.definesAttribute(), definingTableName, definingTableAlias, referenceMdBusinessIF, referenceTableAlias, vq, new HashSet<Join>(), GeoSynonymArrayView.GEOENTITY, GeoSynonymArrayView.GEOENTITY);
      
      
      vQuery.map(GeoSynonymArrayView.SYNONYMIDS, synonymIds);
      vQuery.map(GeoSynonymArrayView.SYNONYMNAMES, synonymNames);
      vQuery.map(GeoSynonymArrayView.GEOENTITY, geoEntity);
      vQuery.map(GeoSynonymArrayView.GEOTYPEDISPLAYLABEL, geoTypeLabel);
      vQuery.map(GeoSynonymArrayView.GEOENTITYNAME, geoEntityLabel);
      
      vq.SELECT(geoType);
    }

    /**
     * Implement only if additional join criteria is required.
     */
    protected void buildWhereClause()
    {
      GeoSynonymArrayViewQuery vQuery = this.getViewQuery();
      vq = vQuery.valueQuery;
      
      vq.FROM(geoSynonymQuery);
      vq.WHERE(synonymRelQuery.getChild().EQ(geoSynonymQuery).AND(synonymRelQuery.getParent().EQ(geoEntityQuery)));
      vq.WHERE(geoType.EQ(geoEntityQuery.getType()));
      vq.GROUP_BY(geoEntity, geoTypeLabel, geoEntityLabel, geoType);
      
      if (this.view != null)
      {
        if (view.getGeoEntity() != null)
        {
          this.addCondition(vQuery.getGeoEntity().EQ(view.getGeoEntity()));
        }
        
//        if (view.getSynonymNames() != null && !view.getSynonymNames().equals(""))
//        {
//          String search = "%" + view.getSynonymNames() + "%";
//          search = search.replace(" ", "% ");
//          
//          this.addCondition(vQuery.getSynonymNames().LIKEi(search));
//        }
        
        if (condition != null)
        {
          vQuery.WHERE(condition);
        }
      }
    }
    
    private void addCondition(Condition newCondition)
    {
      if (condition == null)
      {
        condition = newCondition;
      }
      else
      {
        condition = AND.get(condition, newCondition);
      }
    }
  }
  
  public Selectable getSelectableRef(String attributeAlias)
  {
    return valueQuery.getSelectableRef(attributeAlias);
  }
  
  public static GeoSynonymArrayViewQuery search(GeoSynonymArrayView view)
  {
    GeoSynonymArrayViewQuery query;
    
    if (view == null)
    {
      query = new GeoSynonymArrayViewQuery(new QueryFactory());
    }
    else
    {
      query = new GeoSynonymArrayViewQuery(new QueryFactory(), view);
    }
    
    query.restrictRows(15, 1);

    return query;
  }
}
